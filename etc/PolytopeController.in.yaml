---
# If true, the FSM transitions are managed by an external tool
Managed: false
# If true and the FSM is self-managed, transitions should be triggered
StepByStep: true
# Change idle behaviour, if true the state is kept until transition,
# otherwise the FSM holds the last state until transition
IdleKeepState: true
# Where to look for state libraries
StatesLibraries:
- "@MC_STATES_DEFAULT_RUNTIME_INSTALL_PREFIX@"
- "@MC_STATES_RUNTIME_INSTALL_PREFIX@"
# Where to look for state files
StatesFiles:
- "@MC_STATES_DEFAULT_RUNTIME_INSTALL_PREFIX@/data"
- "@MC_STATES_RUNTIME_INSTALL_PREFIX@/data"
# If true, state factory will be more verbose
VerboseStateFactory: false

# init_pos:
#   translation: [0.0, 0.0, 0.837656]
  # rotation: [0.0, 0.0, 1.570796327]

# Additional robots to load
robots:
  ground:
    module: env/ground
  # wall:
  #   module: env/table
  #   init_pos:
  #     translation: [1.5, -0.2, 1.0]
  #     # translation: [1.2, -0.6, 1.0]
  #     rotation: [0.0, -1.57, 0.0]
  # jvrc1:
  #   module: JVRC1
  #   init_pos:
  #     translation: [0., 1.2, 0.8275]
  #     rotation: [0.0, 0.0, -1.570796327]
  box:
    module: object/box
    init_pos:
      translation: [0.4, 0., 0.9]
      rotation: [0., 0., 0.]
# General constraints, always on
constraints:
- type: contact
- type: dynamics
  damper: [0.1, 0.01, 0.5]
  # infTorque: true
# - type: dynamics
#   robot: jvrc1
#   damper: [0.1, 0.01, 0.5]
  # infTorque: true
- type: dynamics
  robot: box
  damper: [0.1, 0.01, 0.5]
- type: compoundJoint
# Collision constraint
collisions:
- type: collision
  useMinimal: true
# Initial set of contacts
contacts:
- r2: ground
  r1Surface: RightFoot
  r2Surface: AllGround
  dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  friction: 0.7
- r2: ground
  r1Surface: LeftFoot
  r2Surface: AllGround
  dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  friction: 0.7
# - r1: jvrc1
#   r2: ground
#   r1Surface: RightFoot
#   r2Surface: AllGround
#   dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
#   friction: 0.7
# - r1: jvrc1
#   r2: ground
#   r1Surface: LeftFoot
#   r2Surface: AllGround
#   dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
#   friction: 0.7
- r1: box
  r2: ground
  r1Surface: Bottom
  r2Surface: AllGround
  dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  friction: 0.7



DCM_VRPTask:
  type: DCM-VRP
  possibleContacts: [RightFoot, LeftFoot, RightHand]
  withPolytopeConstraints: true
  withAutoBalance: false
  zeroMomentAutoBalance: true
  tracker:
    P: 10
    I: 0
    D: 0
  robotMass:
    rhps1: 61.264
    hrp4: 35.178
    rhps1_plate_plate: 59.401
  tasks:
    CoM:
      weight: 10000
    Momentum:
      # Ideally we want 0 stiffness and only track Ldot (damping)
      # For now since we want static we still target 0 momentum (stiffness)
      stiffness: [3, 3, 5, 0, 0, 0]
      damping: [3, 3, 5, 0, 0, 0]
      weight: 10000
      dimWeight: [1, 1, 1, 0, 0, 0]
    CoP:
      admittance:
        couple: [0.03, 0.03, 0.]
        force: [0.001, 0.001, 0.0002]
      stiffness: 5
      damping: 150
      weight: 100000
      maxVel:
        angular: [3., 3., 3.]
        linear: [1., 1., 1.]

VRPTask:
  type: VRP
  above: [LeftFoot, RightFoot]
  weight: 100000
  stiffness: 10
  withBounding: false
  CoP:
    admittance:
      couple: [0.01, 0.01, 0.]
      force: [0.0, 0.0, 0.0]
    stiffness: 5
    damping: 300
    weight: 1000
    maxVel:
      angular: [3., 3., 3.]
      linear: [1., 1., 1.]

DCMTask:
  type: DCM
  above: [LeftFoot, RightFoot]
  weight: 100000
  stiffness: 10

DynamicPolytope:
  mainRobot:
    # TODO find a way to avoid having to declare them
    possibleContacts: [RightFoot, LeftFoot, RightHand, LeftHand]
    withMoments: false
    computeRegions: false
    gui:
      polyhedronForce: &polyhedron
        triangle_color: [1.0, 0.0, 0.0, 0.2]
        show_triangle: true
        use_triangle_color: false
        edges:
          color: [0.75, 0.75, 0.75, 1.0]
          width: 0.003
          style: solid
        show_edges: false
        fixed_edge_color: true
        vertices:
          color: [1.0, 0.0, 0.0, 1.0]
          scale: 0.02
        show_vertices: false
        fixed_vertices_color: true
      polyhedronMoment:
        <<: *polyhedron
        triangle_color: [0.0, 0.0, 1.0, 0.2]
      polyhedronZMP:
        <<: *polyhedron
        triangle_color: [0.0, 1.0, 0.0, 0.2]
      polyhedronZeroMomentArea:
        <<: *polyhedron
        triangle_color: [0.7, 0.3, 0.0, 0.2]
  jvrc1:
    possibleContacts: [RightFoot, LeftFoot, LeftGripFlat]
    withMoments: false
    computeRegions: false
    gui:
      polyhedronForce: &polyhedron
        triangle_color: [1.0, 0.0, 0.0, 0.2]
        show_triangle: true
        use_triangle_color: false
        edges:
          color: [0.75, 0.75, 0.75, 1.0]
          width: 0.003
          style: solid
        show_edges: false
        fixed_edge_color: true
        vertices:
          color: [1.0, 0.0, 0.0, 1.0]
          scale: 0.02
        show_vertices: false
        fixed_vertices_color: true
      polyhedronMoment:
        <<: *polyhedron
        triangle_color: [0.0, 0.0, 1.0, 0.2]
      polyhedronZMP:
        <<: *polyhedron
        triangle_color: [0.0, 1.0, 0.0, 0.2]
      polyhedronZeroMomentArea:
        <<: *polyhedron
        triangle_color: [0.7, 0.3, 0.0, 0.2]


# Some options for a specific robot
jvrc1:
  posture:
    stiffness: 1
    weight: 10
  ff:
    stiffness: 2
    weight: 100
# Implement some additional text states
states:

  SoloVRP:
    base: MetaTasks
    tasks:
      VRPTask:
        type: VRP
        above: [LeftFoot, RightFoot]
        weight: 100000
        stiffness: 10
        CoP:
          admittance:
            couple: [0.03, 0.03, 0.]
            force: [0.001, 0.001, 0.0002]
          stiffness: 5
          damping: 150
          weight: 100000
          maxVel:
            angular: [3., 3., 3.]
            linear: [1., 1., 1.]

  SoloMomentum:
    base: MetaTasks
    tasks:
      MomentumTask:
        type: momentum


  ContactWall:
    base: MetaTasks
    tasks:
      RightHandTraj:
        type: transform
        frame: RightHand
        weight: 1000
        stiffness: 5
        targetSurface:
          robot: wall
          surface: TableTop
          # offset_translation: [-0.05, -0.2, 0.0]
          # offset_rotation: [0.0, -1.57, 0.0]
        completion:
          eval: 0.01
      # CoM:
      #   type: com
      #   above: [LeftFoot, RightFoot]
      #   weight: 2000
      #   stiffness: 5
    AddContactsAfter:
      - r2: wall
        r1Surface: RightHand
        r2Surface: TableTop
        dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        friction: 0.8

  TouchHands:
    base: MetaTasks
    tasks:
      RightHandTrajR1:
        type: transform
        frame: RightHand
        weight: 1000
        stiffness: 5
        target:
          rotation: [0., -1.57, 1.57]
          translation: [0.3, 0.65, 1.]
          # offset_translation: [-0.05, -0.2, 0.0]
          # offset_rotation: [0.0, -1.57, 0.0]
        completion:
          eval: 0.01
      LeftHandTrajR2:
        type: transform
        robot: jvrc1
        frame: LeftGripFlat
        weight: 1000
        stiffness: 5
        target:
          rotation: [0., -1.57, -1.57]
          translation: [0.3, 0.65, 1.]
          # offset_translation: [-0.05, -0.2, 0.0]
          # offset_rotation: [0.0, -1.57, 0.0]
        completion:
          eval: 0.01
      # No need, building VRP on main robot in constructor
      # CoMR1:
      #   type: VRP
      #   above: [LeftFoot, RightFoot]
      #   weight: 10000
      #   stiffness: 10
      CoMR2:
        type: VRP #com
        robot: jvrc1
        above: [LeftFoot, RightFoot]
        # weight: 2000
        # stiffness: 5
    AddContactsAfter:
      - r2: jvrc1
        r1Surface: RightHand
        r2Surface: LeftGripFlat
        dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        friction: 0.8

  GrabBox:
    base: MetaTasks
    tasks:
      RightHandTraj:
        type: transform
        frame: RightHand
        weight: 1000
        stiffness: 5
        targetFrame:
          robot: box
          frame: Left
          offset:
            translation: [0.0, 0.0, 0.0]
            rotation: [3.14, 0.0, -1.57]
        completion:
          eval: 0.01
      LeftHandTraj:
        type: transform
        frame: LeftHand
        weight: 1000
        stiffness: 5
        targetFrame:
          robot: box
          frame: Right
          offset:
            translation: [0.0, 0.0, 0.0]
            rotation: [3.14, 0.0, 1.57]
        completion:
          eval: 0.01
    AddContactsAfter:
      - r2: box
        r1Surface: RightHand
        r2Surface: Left
        dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        friction: 0.7
      - r2: box
        r1Surface: LeftHand
        r2Surface: Right
        dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        friction: 0.7
    RemoveContactsAfter:
      - r1: box
        r2: ground
        r1Surface: Bottom
        r2Surface: AllGround

  GrabBoxUnder:
    base: MetaTasks
    tasks:
      RightHandTraj:
        type: transform
        frame: RightHand
        weight: 1000
        stiffness: 5
        targetFrame:
          robot: box
          frame: Bottom
          offset:
            translation: [0.0, 0.0, 0.0]
            rotation: [3.14, 0.0, 4.71]
        completion:
          eval: 0.01
    AddContactsAfter:
      - r2: box
        r1Surface: RightHand
        r2Surface: Bottom
        dof: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        friction: 0.7
    RemoveContactsAfter:
      - r1: box
        r2: ground
        r1Surface: Bottom
        r2Surface: AllGround

  VRPBox:
    base: MetaTasks
    tasks:
      BoxVRP:
        type: VRP
        robot: box
        withBounding: false
        weight: 100000
        stiffness: 10


# Transitions map
transitions:
- [EstimateMass, OK, PolytopeController_Initial, Auto]
# - [PolytopeController_Initial, OK, ContactWall, Strict]
# - [PolytopeController_Initial, OK, SoloVRP, Strict]
# - [PolytopeController_Initial, OK, SoloMomentum, Auto]
# - [PolytopeController_Initial, OK, TouchHands, Strict]
- [PolytopeController_Initial, OK, GrabBox, Strict]
# - [PolytopeController_Initial, OK, VRPBox, Strict]
# - [PolytopeController_Initial, OK, GrabBoxUnder, Strict]
- [GrabBox, OK, VRPBox, Strict]
- [GrabBoxUnder, OK, VRPBox, Strict]
- [ContactWall, OK, Pause, Strict]
- [TouchHands, OK, Pause, Strict]
# Initial state
init: PolytopeController_Initial

ObserverPipelines:
- name: MainRobPipeline                    # - Create a new pipeline
  gui: true                              #   diplay the pipeline in the GUI (default = false)
  log: true                              #   log observers (default)
  observers:                             #   declare which observers to use
  - type: Encoder                        # - Use an EncoderObserver
    config:
      position: encoderValues            #    - Sets joint position from encoder sensor values (default)
      velocity: encoderFiniteDifferences #    - Computes joint velocities by finite differences  (default)
      computeFV: true                    # We now have the estimation of each joint position and velocity and the corresponding body positions and velocities, but we are still missing the floating base
  - type: Attitude
    config:
      bodySensor: Accelerometer
  - type: KinematicInertial              # - Estimates the floating base state using the KinematicInertial observer
    update: true                         #   update the real robot instance from its results
    gui: true                            #   Displays the estimated velocity as an arrow (default)
    config:
      bodySensor: Accelerometer          # This observer only uses roll and pitch rotation information from this sensor along with a kinematic anchor point and the robot kinematics between the anchor frame and the floating base frame.
- name: BoxPipeline
  gui: true
  log: true
  observers:
  - type: BodySensor                     # - Use a BodySensor observer
    update: true                        #   Update the real robot state
    gui: true                           #   Display in the gui
    config:
      robot: box
      bodySensor: FloatingBase
